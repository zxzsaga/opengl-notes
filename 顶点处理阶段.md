在顶点处理阶段，对象空间模型将贯穿多个空间，直至到达剪裁空间：

![transform](images/transform.png)

model, view, projection 三个转换的矩阵组成俗称的 MVP 矩阵。

三维空间转换可用齐次坐标 4x4 矩阵描述。

缩放：
$$
\begin{bmatrix}
s_x & 0 & 0 & 0 \\
0 & s_y & 0 & 0 \\
0 & 0 & s_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
z \\
1 \\
\end{bmatrix}
=
\begin{bmatrix}
s_{x}x \\
s_{y}y \\
s_{z}z \\
1 \\
\end{bmatrix}
$$

绕某轴旋转（观察坐标系的原点，且旋转轴指向观察者，逆时针旋转的角度为旋转角度）：
$$
R_x=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & cos\theta & -sin\theta & 0 \\
0 & sin\theta & cos\theta & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$
R_y=
\begin{bmatrix}
cos\theta & 0 & sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-sin\theta & 0 & cos\theta & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$


$$
R_z=
\begin{bmatrix}
cos\theta & -sin\theta & 0 & 0 \\
sin\theta & cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

平移：
$$
\begin{bmatrix}
1 & 0 & 0 & d_x \\
0 & 1 & 0 & d_y \\
0 & 0 & 1 & d_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
z \\
1 \\
\end{bmatrix}
=
\begin{bmatrix}
x+d_x \\
y+d_y \\
z+d_z \\
1 \\
\end{bmatrix}
$$

矩阵变换的顺序必须是：
1. 缩放
2. 旋转
3. 平移

对于法线的转换，令 M 为多边形网格的转换矩阵，即全部顶点通过矩阵 M 进行转换。
- 如果 M 包含了非均匀缩放操作，则矩阵 M 不能用于该对象的表面法线转换。
- M 逆矩阵的转置矩阵 $(M^{-1})^T$ 可用于法线的转换操作。

world transform 用上述空间转换操作即可完成。

在 view transform 中，需要定义相机的状态。用三个向量描述：
- EYE: 相机在世界空间的位置
- AT: 相机场景中所指向的参考点
- UP: （大致）指向相机上方的向量（多数时候定义为世界空间的 y 轴）


用上图所示的方法来确定相机空间的单位向量 u, v, n.

然后可以推导出：
$$
M_{view}=
\begin{bmatrix}
u_x & u_y & u_z & 0 \\
v_x & v_y & v_z & 0 \\
n_x & n_y & n_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & -EYE_x \\
0 & 1 & 0 & -EYE_y \\
0 & 0 & 1 & -EYE_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
=
\begin{bmatrix}
u_x & u_y & u_z & -EYE\cdot u \\
v_x & v_y & v_z & -EYE\cdot v \\
n_x & n_y & n_z & -EYE\cdot n \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

应用这个矩阵，即可将世界空间里的对象转换至相机空间内。

考虑到相机有限的视域范围，通常无法捕捉到场景中的全部对象。所以需要定义场景中的可见区域，称为视见体，通过如下4个参数定义：
- fovy: 垂直方向上的可见区域
- aspect: 宽高比
- n: 近剪裁面距离
- f: 远剪裁面距离


投影矩阵将视锥体转换为2x2x1的立方体视见体，使场景中的3D对象产生变形效果。


投影矩阵：
$$
\begin{bmatrix}
cot{fovy\over 2}\over aspect& 0 & 0 & 0 \\
0 & cot{fovy\over 2} & 0 & 0 \\
0 & 0 & f\over{f-n} & nf\over{f-n} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
$$

通常情况下，投影转换顶点的w坐标定义为-n, 而非1。

在顶点处理阶段，投影转换可视为最后一步操作。随后顶点将进入硬件光栅化阶段。在光栅化阶段，剪裁空间假设采用左手规则，因此需要在右手系统和左手系统之间进行转换。所以需要进行重建模操作，即调整顶点顺序（右手系统三角形顶点按逆时针顺序排列，左手系统则按顺时针）以及z逆置操作。通过对硬件光栅化操作进行调整，可有效地解决顶点顺序问题，所以唯一需要处理的问题是z逆置操作。这只需要修改一下上述的投影矩阵即可：
$$
\begin{bmatrix}
cot{fovy\over 2}\over aspect& 0 & 0 & 0 \\
0 & cot{fovy\over 2} & 0 & 0 \\
0 & 0 & -{f\over{f-n}} & -{nf\over{f-n}} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
$$

这样就可以得到：


Direct3D 里使用行向量，所以投影矩阵是上述矩阵的转置矩阵：
$$
\begin{bmatrix}
cot{fovy\over 2}\over aspect& 0 & 0 & 0 \\
0 & cot{fovy\over 2} & 0 & 0 \\
0 & 0 & -{f\over{f-n}} & -1 \\
0 & 0 & -{nf\over{f-n}} & 0 \\
\end{bmatrix}
$$

而 OpenGL 的投影矩阵将视锥体转换为立方体，x, y, z 的范围都是[-1, 1]. OpenGL 里 z 值范围为[-1, 1]，而不是[0, 1], 所以投影矩阵也有所不同：
$$
\begin{bmatrix}
cot{fovy\over 2}\over aspect& 0 & 0 & 0 \\
0 & cot{fovy\over 2} & 0 & 0 \\
0 & 0 & -{f+n\over{f-n}} & -{2nf\over{f-n}} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
$$
